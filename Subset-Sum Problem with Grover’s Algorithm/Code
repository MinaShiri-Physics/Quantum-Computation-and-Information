{
  "cells": [
    {
      "cell_type": "markdown",
      "source": [
        "# Libraries"
      ],
      "metadata": {
        "id": "u_VZNfNN27x6"
      }
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "a6eb0bd6",
        "outputId": "0ef482ce-d370-496a-f056-cc59acde2c37"
      },
      "source": [
        "!pip install numpy qiskit qiskit-aer matplotlib pylatexenc\n",
        "import numpy as np\n",
        "from qiskit import QuantumCircuit, QuantumRegister, ClassicalRegister\n",
        "from qiskit.circuit.library import QFT\n",
        "from qiskit_aer.primitives import Sampler\n",
        "import matplotlib.pyplot as plt"
      ],
      "execution_count": 1,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Requirement already satisfied: numpy in /usr/local/lib/python3.11/dist-packages (2.0.2)\n",
            "Collecting qiskit\n",
            "  Downloading qiskit-2.1.1-cp39-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (12 kB)\n",
            "Collecting qiskit-aer\n",
            "  Downloading qiskit_aer-0.17.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (8.3 kB)\n",
            "Requirement already satisfied: matplotlib in /usr/local/lib/python3.11/dist-packages (3.10.0)\n",
            "Collecting pylatexenc\n",
            "  Downloading pylatexenc-2.10.tar.gz (162 kB)\n",
            "\u001b[2K     \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m162.6/162.6 kB\u001b[0m \u001b[31m5.5 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25h  Preparing metadata (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "Collecting rustworkx>=0.15.0 (from qiskit)\n",
            "  Downloading rustworkx-0.16.0-cp39-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl.metadata (10 kB)\n",
            "Requirement already satisfied: scipy>=1.5 in /usr/local/lib/python3.11/dist-packages (from qiskit) (1.16.0)\n",
            "Requirement already satisfied: dill>=0.3 in /usr/local/lib/python3.11/dist-packages (from qiskit) (0.3.8)\n",
            "Collecting stevedore>=3.0.0 (from qiskit)\n",
            "  Downloading stevedore-5.4.1-py3-none-any.whl.metadata (2.3 kB)\n",
            "Requirement already satisfied: typing-extensions in /usr/local/lib/python3.11/dist-packages (from qiskit) (4.14.1)\n",
            "Requirement already satisfied: psutil>=5 in /usr/local/lib/python3.11/dist-packages (from qiskit-aer) (5.9.5)\n",
            "Requirement already satisfied: python-dateutil>=2.8.0 in /usr/local/lib/python3.11/dist-packages (from qiskit-aer) (2.9.0.post0)\n",
            "Requirement already satisfied: contourpy>=1.0.1 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (1.3.2)\n",
            "Requirement already satisfied: cycler>=0.10 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (0.12.1)\n",
            "Requirement already satisfied: fonttools>=4.22.0 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (4.59.0)\n",
            "Requirement already satisfied: kiwisolver>=1.3.1 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (1.4.8)\n",
            "Requirement already satisfied: packaging>=20.0 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (25.0)\n",
            "Requirement already satisfied: pillow>=8 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (11.3.0)\n",
            "Requirement already satisfied: pyparsing>=2.3.1 in /usr/local/lib/python3.11/dist-packages (from matplotlib) (3.2.3)\n",
            "Requirement already satisfied: six>=1.5 in /usr/local/lib/python3.11/dist-packages (from python-dateutil>=2.8.0->qiskit-aer) (1.17.0)\n",
            "Collecting pbr>=2.0.0 (from stevedore>=3.0.0->qiskit)\n",
            "  Downloading pbr-6.1.1-py2.py3-none-any.whl.metadata (3.4 kB)\n",
            "Requirement already satisfied: setuptools in /usr/local/lib/python3.11/dist-packages (from pbr>=2.0.0->stevedore>=3.0.0->qiskit) (75.2.0)\n",
            "Downloading qiskit-2.1.1-cp39-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (7.5 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m7.5/7.5 MB\u001b[0m \u001b[31m105.7 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading qiskit_aer-0.17.1-cp311-cp311-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (12.4 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m12.4/12.4 MB\u001b[0m \u001b[31m135.2 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading rustworkx-0.16.0-cp39-abi3-manylinux_2_17_x86_64.manylinux2014_x86_64.whl (2.1 MB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m2.1/2.1 MB\u001b[0m \u001b[31m94.0 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading stevedore-5.4.1-py3-none-any.whl (49 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m49.5/49.5 kB\u001b[0m \u001b[31m5.4 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hDownloading pbr-6.1.1-py2.py3-none-any.whl (108 kB)\n",
            "\u001b[2K   \u001b[90m━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━\u001b[0m \u001b[32m109.0/109.0 kB\u001b[0m \u001b[31m9.9 MB/s\u001b[0m eta \u001b[36m0:00:00\u001b[0m\n",
            "\u001b[?25hBuilding wheels for collected packages: pylatexenc\n",
            "  Building wheel for pylatexenc (setup.py) ... \u001b[?25l\u001b[?25hdone\n",
            "  Created wheel for pylatexenc: filename=pylatexenc-2.10-py3-none-any.whl size=136817 sha256=6a83a1f8d9fb90daec84c49faeb2710a07a4c3f4d34d5ffc51389256037e3834\n",
            "  Stored in directory: /root/.cache/pip/wheels/b1/7a/33/9fdd892f784ed4afda62b685ae3703adf4c91aa0f524c28f03\n",
            "Successfully built pylatexenc\n",
            "Installing collected packages: pylatexenc, rustworkx, pbr, stevedore, qiskit, qiskit-aer\n",
            "Successfully installed pbr-6.1.1 pylatexenc-2.10 qiskit-2.1.1 qiskit-aer-0.17.1 rustworkx-0.16.0 stevedore-5.4.1\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8d3085f2"
      },
      "source": [
        "## Classical SSolution\n",
        "\n",
        "We define the set of numbers (weights) and the target sum.\n",
        "For this example, we use n=4 as requested."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "a0be36a1",
        "outputId": "fafc919c-f1ac-43ed-ab26-a278b60dcdd9"
      },
      "source": [
        "weights = [1, 2, 4, 5]\n",
        "target_sum = 7\n",
        "\n",
        "# --- Find classical solutions for verification ---\n",
        "# This helps us know what to expect from the quantum algorithm.\n",
        "def find_classical_solutions(weights, target):\n",
        "    \"\"\"Finds all subsets that sum to the target value classically.\"\"\"\n",
        "    solutions = []\n",
        "    num_weights = len(weights)\n",
        "    for i in range(2**num_weights):\n",
        "        current_sum = 0\n",
        "        # Format the number `i` as a binary string with leading zeros\n",
        "        bit_string = format(i, f'0{num_weights}b')\n",
        "        for j in range(num_weights):\n",
        "            if bit_string[j] == '1':\n",
        "                current_sum += weights[j]\n",
        "        if current_sum == target:\n",
        "            # Qiskit reads bitstrings from right to left, so we reverse it\n",
        "            solutions.append(bit_string[::-1])\n",
        "    return solutions\n",
        "\n",
        "classical_solutions = find_classical_solutions(weights, target_sum)\n",
        "print(f\"Problem: Find a subset of {weights} that sums to {target_sum}\")\n",
        "if classical_solutions:\n",
        "    print(f\"Classical solutions (bitstrings): {classical_solutions}\")\n",
        "else:\n",
        "    print(\"No classical solution found.\")"
      ],
      "execution_count": 2,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Problem: Find a subset of [1, 2, 4, 5] that sums to 7\n",
            "Classical solutions (bitstrings): ['1010', '0111']\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "b2d9fe16"
      },
      "source": [
        "## Quantum Algorithm Components"
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "2ac6e7a6"
      },
      "source": [
        "### Quantum Adder Circuit\n",
        "\n",
        "This circuit calculates the sum Σ(w_i * x_i) into a sum register.\n",
        "We use a Quantum Fourier Transform (QFT) based adder."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "08805725"
      },
      "source": [
        "def controlled_adder(qc, weights, var_qubits, sum_qubits):\n",
        "    \"\"\"\n",
        "    Creates a circuit to add weights to the sum_qubits register,\n",
        "    controlled by the var_qubits register.\n",
        "    \"\"\"\n",
        "    num_sum_qubits = len(sum_qubits)\n",
        "    for i, weight in enumerate(weights):\n",
        "        # For each weight, apply controlled phase rotations\n",
        "        for j in range(num_sum_qubits):\n",
        "            # The angle of rotation depends on the weight and the qubit's place value\n",
        "            angle = (2 * np.pi * weight) / (2**(j + 1))\n",
        "            qc.cp(angle, var_qubits[i], sum_qubits[j])\n",
        "\n",
        "def sum_circuit(weights, num_var_qubits):\n",
        "    \"\"\"\n",
        "    Constructs the full quantum adder circuit.\n",
        "    \"\"\"\n",
        "    # Determine the number of qubits needed for the sum\n",
        "    max_sum = sum(weights)\n",
        "    num_sum_qubits = int(np.ceil(np.log2(max_sum + 1))) if max_sum > 0 else 1\n",
        "\n",
        "    # Define quantum registers\n",
        "    var_reg = QuantumRegister(num_var_qubits, name='var')\n",
        "    sum_reg = QuantumRegister(num_sum_qubits, name='sum')\n",
        "    qc = QuantumCircuit(var_reg, sum_reg, name='Sum')\n",
        "\n",
        "    # 1. Apply QFT to the sum register\n",
        "    qc.append(QFT(num_sum_qubits, do_swaps=False, name='QFT'), sum_reg)\n",
        "\n",
        "    # 2. Add weights controlled by variable qubits\n",
        "    controlled_adder(qc, weights, var_reg, sum_reg)\n",
        "\n",
        "    # 3. Apply inverse QFT to get the sum in binary\n",
        "    qc.append(QFT(num_sum_qubits, do_swaps=False, inverse=True, name='IQFT'), sum_reg)\n",
        "\n",
        "    # Decompose the circuit into basic gates before returning\n",
        "    return qc.decompose(), num_sum_qubits"
      ],
      "execution_count": 3,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "8ff6744b"
      },
      "source": [
        "### Oracle Circuit\n",
        "\n",
        "The oracle marks the states where the sum equals the target."
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "2541be8a"
      },
      "source": [
        "def oracle(weights, target_sum):\n",
        "    \"\"\"\n",
        "    Constructs the oracle for the Subset-Sum problem.\n",
        "    It marks states |x> where the sum of selected weights equals target_sum.\n",
        "    \"\"\"\n",
        "    num_var_qubits = len(weights)\n",
        "\n",
        "    # Create the adder circuit to compute the sum\n",
        "    adder_qc, num_sum_qubits = sum_circuit(weights, num_var_qubits)\n",
        "\n",
        "    # Define all necessary registers\n",
        "    var_reg = QuantumRegister(num_var_qubits, name='var')\n",
        "    sum_reg = QuantumRegister(num_sum_qubits, name='sum')\n",
        "    flag_qubit = QuantumRegister(1, name='flag') # This qubit is flipped if sum == target\n",
        "\n",
        "    oracle_qc = QuantumCircuit(var_reg, sum_reg, flag_qubit, name='Oracle')\n",
        "\n",
        "    # 1. Compute the sum\n",
        "    oracle_qc.append(adder_qc.to_gate(), oracle_qc.qubits[:num_var_qubits + num_sum_qubits])\n",
        "\n",
        "    # 2. Compare the sum with the target\n",
        "    # Convert target to binary string\n",
        "    target_binary = format(target_sum, f'0{num_sum_qubits}b')[::-1] # Reverse for Qiskit's order\n",
        "\n",
        "    # Flip sum qubits that are '0' in the target binary representation\n",
        "    for i in range(num_sum_qubits):\n",
        "        if target_binary[i] == '0':\n",
        "            oracle_qc.x(sum_reg[i])\n",
        "\n",
        "    # 3. Mark the state if all sum qubits are now |1> (i.e., sum == target)\n",
        "    oracle_qc.mcx(sum_reg, flag_qubit)\n",
        "\n",
        "    # 4. Uncomputation: Reverse the comparison and sum calculation\n",
        "    # to restore qubits to their original state (crucial for Grover's)\n",
        "    for i in range(num_sum_qubits):\n",
        "        if target_binary[i] == '0':\n",
        "            oracle_qc.x(sum_reg[i])\n",
        "\n",
        "    oracle_qc.append(adder_qc.inverse().to_gate(), oracle_qc.qubits[:num_var_qubits + num_sum_qubits])\n",
        "\n",
        "    return oracle_qc"
      ],
      "execution_count": 4,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "589a1ff5"
      },
      "source": [
        "### Diffuser (Amplifier) Circuit"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "id": "e187773e"
      },
      "source": [
        "def diffuser(num_var_qubits):\n",
        "    \"\"\"\n",
        "    Constructs the Grover diffuser (amplitude amplification) circuit.\n",
        "    \"\"\"\n",
        "    qc = QuantumCircuit(num_var_qubits, name='Diffuser')\n",
        "\n",
        "    # Apply H-gates to all variable qubits\n",
        "    qc.h(range(num_var_qubits))\n",
        "    # Apply X-gates to all variable qubits\n",
        "    qc.x(range(num_var_qubits))\n",
        "\n",
        "    # Apply multi-controlled Z-gate\n",
        "    qc.h(num_var_qubits - 1)\n",
        "    qc.mcx(list(range(num_var_qubits - 1)), num_var_qubits - 1)\n",
        "    qc.h(num_var_qubits - 1)\n",
        "\n",
        "    # Apply X-gates and H-gates again\n",
        "    qc.x(range(num_var_qubits))\n",
        "    qc.h(range(num_var_qubits))\n",
        "\n",
        "    return qc"
      ],
      "execution_count": 5,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "c90d5c38"
      },
      "source": [
        "## Main Grover Algorithm Construction"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "f00c2b7c",
        "outputId": "af3f3583-3322-42b5-f44a-75db23d70c31"
      },
      "source": [
        "num_var_qubits = len(weights)\n",
        "\n",
        "# --- Determine optimal number of Grover iterations ---\n",
        "# N = 2^n, M = number of solutions\n",
        "N = 2**num_var_qubits\n",
        "M = len(classical_solutions) if len(classical_solutions) > 0 else 1\n",
        "# The formula is (pi/4) * sqrt(N/M)\n",
        "num_iterations = int(np.floor(np.pi / 4 * np.sqrt(N / M)))\n",
        "print(f\"Optimal number of Grover iterations: {num_iterations}\")\n",
        "\n",
        "\n",
        "# --- Build the full circuit ---\n",
        "# Get the oracle and diffuser circuits\n",
        "oracle_qc = oracle(weights, target_sum)\n",
        "diffuser_qc = diffuser(num_var_qubits)\n",
        "\n",
        "# Define all registers for the final circuit\n",
        "var_reg = QuantumRegister(num_var_qubits, name='var')\n",
        "# The oracle needs auxiliary qubits for sum and a flag\n",
        "sum_reg = oracle_qc.qregs[1]\n",
        "flag_qubit = oracle_qc.qregs[2]\n",
        "# We need a classical register to store measurement results\n",
        "cr = ClassicalRegister(num_var_qubits, name='c')\n",
        "\n",
        "# Main circuit\n",
        "grover_circuit = QuantumCircuit(var_reg, sum_reg, flag_qubit, cr)\n",
        "\n",
        "# 1. Initialize state\n",
        "# Put variable qubits in superposition\n",
        "grover_circuit.h(var_reg)\n",
        "# Initialize the flag qubit to |-> state\n",
        "grover_circuit.x(flag_qubit)\n",
        "grover_circuit.h(flag_qubit)\n",
        "grover_circuit.barrier()\n",
        "\n",
        "# 2. Apply Grover iterations\n",
        "for _ in range(num_iterations):\n",
        "    # Connect the oracle to ALL its required qubits\n",
        "    all_oracle_qubits = var_reg[:] + sum_reg[:] + flag_qubit[:]\n",
        "    grover_circuit.append(oracle_qc.to_gate(), all_oracle_qubits)\n",
        "\n",
        "    # The diffuser only acts on the variable qubits.\n",
        "    grover_circuit.append(diffuser_qc.to_gate(), var_reg)\n",
        "    grover_circuit.barrier()\n",
        "\n",
        "# 3. Measure the variable qubits\n",
        "grover_circuit.measure(var_reg, cr)\n",
        "\n",
        "# Optional: Draw the circuit\n",
        "# print(grover_circuit.draw(output='text', fold=-1))"
      ],
      "execution_count": 6,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "Optimal number of Grover iterations: 2\n"
          ]
        },
        {
          "output_type": "stream",
          "name": "stderr",
          "text": [
            "/tmp/ipython-input-3841952605.py:28: DeprecationWarning: The class ``qiskit.circuit.library.basis_change.qft.QFT`` is deprecated as of Qiskit 2.1. It will be removed in Qiskit 3.0. ('Use qiskit.circuit.library.QFTGate or qiskit.synthesis.qft.synth_qft_full instead, for access to all previous arguments.',)\n",
            "  qc.append(QFT(num_sum_qubits, do_swaps=False, name='QFT'), sum_reg)\n",
            "/tmp/ipython-input-3841952605.py:34: DeprecationWarning: The class ``qiskit.circuit.library.basis_change.qft.QFT`` is deprecated as of Qiskit 2.1. It will be removed in Qiskit 3.0. ('Use qiskit.circuit.library.QFTGate or qiskit.synthesis.qft.synth_qft_full instead, for access to all previous arguments.',)\n",
            "  qc.append(QFT(num_sum_qubits, do_swaps=False, inverse=True, name='IQFT'), sum_reg)\n"
          ]
        },
        {
          "output_type": "execute_result",
          "data": {
            "text/plain": [
              "<qiskit.circuit.instructionset.InstructionSet at 0x7ca7827ad5d0>"
            ]
          },
          "metadata": {},
          "execution_count": 6
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "3584505e"
      },
      "source": [
        "## Simulation and Results\n",
        "\n",
        "\n"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/"
        },
        "id": "4a11ff2e",
        "outputId": "8861ad0b-dac4-4207-dd25-0050476ff072"
      },
      "source": [
        "print(\"\\nRunning simulation...\")\n",
        "sampler = Sampler()\n",
        "job = sampler.run(grover_circuit, shots=1024)\n",
        "result = job.result()\n",
        "\n",
        "# Extract and process the results\n",
        "quasi_dist = result.quasi_dists[0]\n",
        "# *** FIX: binary_probabilities() already returns a dictionary with bitstring keys ***\n",
        "# No need to format the keys again.\n",
        "counts = quasi_dist.binary_probabilities()\n",
        "\n",
        "print(\"Simulation finished.\")\n",
        "print(\"\\nResults:\")\n",
        "print(counts)"
      ],
      "execution_count": 7,
      "outputs": [
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\n",
            "Running simulation...\n",
            "Simulation finished.\n",
            "\n",
            "Results:\n",
            "{'1111': 0.0009765625, '0001': 0.0029296875, '1010': 0.48828125, '0111': 0.4541015625, '0011': 0.005859375, '1011': 0.0048828125, '1101': 0.0029296875, '1100': 0.005859375, '0110': 0.0009765625, '1000': 0.0087890625, '1001': 0.0068359375, '0101': 0.0068359375, '1110': 0.0048828125, '0010': 0.0029296875, '0100': 0.0029296875}\n"
          ]
        }
      ]
    },
    {
      "cell_type": "markdown",
      "metadata": {
        "id": "847b6101"
      },
      "source": [
        "## Visualization"
      ]
    },
    {
      "cell_type": "code",
      "metadata": {
        "colab": {
          "base_uri": "https://localhost:8080/",
          "height": 641
        },
        "id": "1b31896f",
        "outputId": "c9298011-243e-449c-e1c3-ec5224f436b4"
      },
      "source": [
        "# Plot the probability distribution\n",
        "fig, ax = plt.subplots(figsize=(12, 6))\n",
        "ax.bar(counts.keys(), counts.values())\n",
        "ax.set_xlabel('Subset (Bitstring)')\n",
        "ax.set_ylabel('Probability')\n",
        "ax.set_title(f\"Subset Sum results for w={weights}, T={target_sum}\")\n",
        "plt.xticks(rotation=90)\n",
        "plt.tight_layout()\n",
        "plt.show()\n",
        "\n",
        "print(\"\\nAnalysis:\")\n",
        "print(\"The bitstrings with the highest probabilities are the solutions.\")\n",
        "print(f\"The classical solutions were: {classical_solutions}\")\n",
        "print(\"Compare these with the peaks in the plot above.\")"
      ],
      "execution_count": 8,
      "outputs": [
        {
          "output_type": "display_data",
          "data": {
            "text/plain": [
              "<Figure size 1200x600 with 1 Axes>"
            ],
            "image/png": "iVBORw0KGgoAAAANSUhEUgAABKUAAAJOCAYAAABm7rQwAAAAOnRFWHRTb2Z0d2FyZQBNYXRwbG90bGliIHZlcnNpb24zLjEwLjAsIGh0dHBzOi8vbWF0cGxvdGxpYi5vcmcvlHJYcgAAAAlwSFlzAAAPYQAAD2EBqD+naQAAWZVJREFUeJzt3XmUFOXZN+B7AGfYt7AjAq6IKKsgGgUjBvc9KkZBVIxGEMUlGhVEExE1uKIYFTUu0ZjXPQomvBCIYlAIYFBRfEVIlAGUHTMs098ffkxspweGYahG5rrO6XPoqurqu2+qaqZ/U/VUTiqVSgUAAAAAJKhStgsAAAAAoOIRSgEAAACQOKEUAAAAAIkTSgEAAACQOKEUAAAAAIkTSgEAAACQOKEUAAAAAIkTSgEAAACQOKEUAAAAAIkTSgHANrjxxhsjJycnli5dmu1S2A7OPffcaNWq1XZ/n3HjxkWHDh2iatWqkZOTE8uXL9/u75mE+fPnR05OTtHjj3/8Y7ZL+t558cUX03r47rvvZrskACg3QikAKpT33nsvTjvttGjZsmVUrVo1mjdvHkceeWTce++92S5tq9xyyy3x4osvlnr5JUuWxODBg6NNmzZRrVq1aNSoUXTt2jV+8YtfxOrVq7dfoTuZtWvXxo033hiTJk0qt3V++eWXcfrpp0e1atVi9OjR8cQTT0SNGjXKbf07ggsvvDCeeOKJ6Nq1a9G01atXx7Bhw+Koo46K+vXrR05OTjz22GPb9D4LFy6M4cOHR9euXaNevXrRoEGD6NmzZ/zlL3/Zxk/wX8uXL49GjRptc8h27rnnpoVNmx5t2rRJW65Lly7xxBNPxIUXXlim9+nZs2fG9/nu48YbbyzzZ5k0adJm1/3rX/+6zOsGYOdWJdsFAEBS3nrrrTj88MNjt912iwEDBkSTJk1i4cKF8fbbb8fdd98dgwYNynaJpXbLLbfEaaedFieddNIWl/3qq6+iS5cusXLlyjjvvPOiTZs28eWXX8bs2bPjgQceiIsvvjhq1qy5/YveCaxduzaGDx8eEd982S8P77zzTqxatSpuvvnm6NWrV7msc0fTvXv3OPvss9OmLV26NG666abYbbfdon379uUS9L300ksxcuTIOOmkk6Jfv36xYcOG+N3vfhdHHnlkjB07Nvr377/N7zF06NBYu3btNq8nIiIvLy8efvjhtGl16tRJe77rrrvG2WefHRs2bIjf/va3W/0e1113XVxwwQVFz995552455574pe//GXsu+++RdMPOOCArV73Jvvuu2888cQTxaY/8cQT8cYbb8SPf/zjMq8bgJ2bUAqACuPXv/511KlTJ955552oW7du2rzFixdnp6gEPPLII7FgwYJ488034+CDD06bt3LlysjNzc1SZaWzdu3aqF69erbL2G42bXvf3Sa3xZo1a3b4s62aNm0aX3zxRTRp0iTefffdOPDAA7d5nYcffngsWLAgGjRoUDTtoosuig4dOsTQoUO3OZT65z//GQ888EAMHTo0hg4duq3lRpUqVYqFdeXtyCOPTHtetWrVuOeee+LII48st2C1cePGGT/H8OHDY6+99iqX/1sAdk4u3wOgwvjkk09iv/32y/jlv1GjRkX/3jQOTqZLiUq6zGXp0qVx+umnR+3ateMHP/hBDB48OP7zn/+kLfPnP/85fvjDH0bdunWjZs2asc8++8Qvf/nLtGUKCgpi2LBhseeee0ZeXl60aNEirr766igoKEirYc2aNfH4448XXR5z7rnnbvZzV65cOQ466KBi82rXrh1Vq1Ytet6qVauM6+rZs2faF9hNl+v84Q9/iOHDh0fz5s2jVq1acdppp8WKFSuioKAgLrvssmjUqFHUrFkz+vfvn/YZStKzZ89o165dTJ8+PQ477LCoXr16UY9K05uILff5sccei5ycnJg/f37a6zZ9ppLO2Jk/f340bNgwIr75sv3dy54WLVoU/fv3j1133TXy8vKiadOmceKJJxZ7n+9+3n79+kVExIEHHljs//K5556Lzp07R7Vq1aJBgwZx9tlnx7///e+0dZx77rlRs2bN+OSTT+KYY46JWrVqxU9/+tOM7zd79uzIycmJl19+uWja9OnTIycnJzp16pS27NFHHx3dunUrsfZtlZeXF02aNCnXde63335pgdSm9znmmGPiX//6V6xatWqb1j948OA4+eST49BDD92m9Xzbxo0bY+XKleW2vh3FtGnTYt68eSVuiwAQ4UwpACqQli1bxtSpU+Of//xntGvXrlzXffrpp0erVq1ixIgR8fbbb8c999wTy5Yti9/97ncRETFnzpw47rjj4oADDoibbrop8vLyYt68efHmm28WraOwsDBOOOGE+Nvf/hYXXnhh7LvvvvHee+/FnXfeGR999FHRGFJPPPFEXHDBBdG1a9eicWb22GOPzX7ujRs3xhNPPFEUgJSXESNGRLVq1eKaa66JefPmxb333hu77LJLVKpUKZYtWxY33nhjvP322/HYY49F69atS3V2yZdffhlHH310nHnmmXH22WdH48aNS92b0vS5rBo2bFh0uePJJ58cp5xySkT897KnU089NebMmRODBg2KVq1axeLFi+PPf/5zLFiwoMTB0q+77rrYZ5994re//W3cdNNN0bp166L/y8ceeyz69+8fBx54YIwYMSLy8/Pj7rvvjjfffDP+8Y9/pIWrGzZsiN69e8cPf/jDuOOOO0o8s6xdu3ZRt27dmDx5cpxwwgkRETFlypSoVKlSzJo1K1auXBm1a9eOwsLCeOutt9LGMVq9enWxoDWTXXbZpdglaNm2aNGiqF69+jadcffcc8/FW2+9FR988MFmg8atsXbt2qhdu3asXbs26tWrF3369ImRI0dm9XLaFStWxPr167e4XNWqVTdb51NPPRURIZQCYPNSAFBBvPHGG6nKlSunKleunOrevXvq6quvTo0fPz61bt26tOU+/fTTVESkHn300WLriIjUsGHDip4PGzYsFRGpE044IW25n//856mISM2aNSuVSqVSd955ZyoiUkuWLCmxvieeeCJVqVKl1JQpU9KmjxkzJhURqTfffLNoWo0aNVL9+vUr1edetGhRqmHDhqmISLVp0yZ10UUXpZ5++unU8uXLiy3bsmXLjOvt0aNHqkePHkXPJ06cmIqIVLt27dL616dPn1ROTk7q6KOPTnt99+7dUy1bttxirT169EhFRGrMmDFp00vbm9L0+dFHH01FROrTTz9Nm77pM02cOLFoWr9+/dLqXrJkSbFtIJVKpZYtW5aKiNTtt9++xc9YUj3vvPNO0bR169alGjVqlGrXrl3q66+/Lpr+6quvpiIiNXTo0LQaIyJ1zTXXlOr9jj322FTXrl2Lnp9yyimpU045JVW5cuXU66+/nkqlUqkZM2akIiL10ksvFXufLT2+vZ1sbl/6tnfeeadUy5XFxx9/nKpatWrqnHPOKfM61q5dm9ptt91S1157bSqV+u+28txzz5V5nddcc03qF7/4RerZZ59N/f73vy/q7yGHHJJav359seUzbSdl8dxzzxXbzr9t0z64pcfmjj8bNmxINW7cOG07A4BMnCkFQIVx5JFHxtSpU2PEiBExfvz4mDp1atx2223RsGHDePjhh4vOHCmLSy65JO35oEGD4v7774/XXnstDjjggKKzWl566aXo379/VKpU/Ar65557Lvbdd99o06ZNLF26tGj6j370o4iImDhxYrExoUqjcePGMWvWrLjpppvihRdeiDFjxsSYMWMiNzc3rr/++rj++usjJydnq9cbEdG3b9/YZZddip5369Ytfv/738d5552Xtly3bt3innvuiQ0bNkSVKpv/9SMvL6/Y2D+l7U1p+rw9VKtWLXJzc2PSpElx/vnnR7169bZpfe+++24sXrw4brzxxrTLK4899tho06ZN/OlPfyoacH2Tiy++uFTrPvTQQ+P6668vGnfqb3/7W9xyyy3x2WefxZQpU+Koo46KKVOmRE5OTvzwhz8set3VV19dqvGPtvWzl6e1a9fGT37yk6hWrVrceuutZV7PrbfeGuvXry92ue22GDFiRNrzM888M/bee++47rrr4o9//GOceeaZ5fZeW+M3v/lNLFu2bIvLNWvWrMR5EyZMiPz8/HLtFwA7J6EUABXKgQceGM8//3ysW7cuZs2aFS+88ELceeedcdppp8XMmTOjbdu2ZVrvXnvtlfZ8jz32iEqVKhVd5nPGGWfEww8/HBdccEFcc801ccQRR8Qpp5wSp512WlFw8vHHH8cHH3xQNG7Rd23LYOxNmzaNBx54IO6///74+OOPY/z48TFy5MgYOnRoNG3aNO3uXFtjt912S3u+6bKtFi1aFJteWFgYK1asiB/84AebXWfz5s2LDb5e2t6Ups/bQ15eXowcOTKuuOKKaNy4cRx00EFx3HHHRd++fcs0btJnn30WERH77LNPsXlt2rSJv/3tb2nTqlSpErvuumup1n3ooYfGhg0bYurUqdGiRYtYvHhxHHrooTFnzpyYMmVKRHxzSV/btm2jfv36Ra9r27ZtmfePbNi4cWOceeaZ8f7778frr7++2RBlc+bPnx+33357jB49ertfVnf55ZfHDTfcEH/5y1+yFkp17tx5m9fx1FNPReXKleOMM84oh4oA2JkJpQCokHJzc+PAAw+MAw88MPbee+/o379/PPfcczFs2LASzxrauHFjqdf/3XVUq1YtJk+eHBMnTow//elPMW7cuHj22WfjRz/6UbzxxhtRuXLlKCwsjP333z9GjRqVcZ3fDXrKIicnJ/bee+/Ye++949hjj4299tornnrqqaJQanOfvXLlysWmZ5q2uempVGqLNVarVq3YtNL2pjR9Lo//30wuu+yyOP744+PFF1+M8ePHxw033BAjRoyI//3f/42OHTtu07q3JC8vr9ShW5cuXaJq1aoxefLk2G233aJRo0ax9957x6GHHhr3339/FBQUxJQpU+Lkk09Oe92KFSvi66+/3uL6c3Nz08KsbBkwYEC8+uqr8dRTTxWdUVcWQ4cOjebNm0fPnj2LQuZFixZFRMSSJUti/vz5sdtuu5VL6FmtWrX4wQ9+EF999dU2r6usvvrqq1i3bt0Wl6tWrVrGscO+/vrreOGFF6JXr17RuHHj7VEiADsRoRQAFV6XLl0iIuKLL76IiP9efrR8+fK05TadvZLJxx9/HK1bty56Pm/evCgsLEwb4LpSpUpxxBFHxBFHHBGjRo2KW265Ja677rqYOHFi9OrVK/bYY4+YNWtWHHHEEVu8nK6sl9t92+677x716tUr+twR33z2737uiG8+++67777N71lWW9ObLfW5LP+/m2zpvffYY4+44oor4oorroiPP/44OnToEL/5zW/iySef3OK6v61ly5YRETF37txigcrcuXOL5pdFbm5udO3aNaZMmRK77bZb0Z3kDj300CgoKIinnnoq8vPz47DDDkt73eDBg+Pxxx/f4vp79OhR4h0Mk3LVVVfFo48+GnfddVf06dNnm9a1YMGCmDdvXsbt/+c//3lERCxbtizjXT231qpVq2Lp0qUlnhGYhFNOOSX++te/bnG5fv36ZbxD6csvvxyrVq0ywDkApSKUAqDCmDhxYvTs2bNYsPDaa69FxH8vlapdu3Y0aNAgJk+eHJdddlnRcvfff3+J6x49enT8+Mc/Lnp+7733RkTE0UcfHRHfnH3w3bNHOnToEBERBQUFEfHNHfxee+21eOihh9LuehbxzdkHhYWFUaNGjYiIqFGjRsbwKJO///3v0a5du6LXbjJt2rT48ssv45BDDimatscee8SUKVNi3bp1RZfQvfrqq7Fw4cKshlKl7U1p+rzp7naTJ08umrdx48b47W9/u8U6Nt297bu9X7t2bVSqVClt/Kc99tgjatWqVfS+W6NLly7RqFGjGDNmTJx33nmRl5cXERGvv/56fPDBB6W6i+HmHHrooTFq1Kj45JNP4oorroiIiAYNGsS+++4bI0eOLFrm274vY0rdfvvtcccdd8Qvf/nLGDx48Dav71e/+lXaOGYREf/85z/jhhtuiKuvvjq6d+9ebN/akv/85z+xfv36qFWrVtr0m2++OVKpVBx11FHbXHdZbeuYUk8//XRUr1692Jl2AJCJUAqACmPQoEGxdu3aOPnkk6NNmzaxbt26eOutt+LZZ5+NVq1apQ2ufcEFF8Stt94aF1xwQXTp0iUmT54cH330UYnr/vTTT+OEE06Io446KqZOnRpPPvlknHXWWdG+ffuIiLjpppti8uTJceyxx0bLli1j8eLFcf/998euu+5aNJj0OeecE3/4wx/ioosuiokTJ8YhhxwSGzdujA8//DD+8Ic/xPjx44vO6urcuXP85S9/iVGjRkWzZs2idevW0a1bt4y1PfHEE/HUU0/FySefHJ07d47c3Nz44IMPYuzYsVG1atW0wYgvuOCC+OMf/xhHHXVUnH766fHJJ5/Ek08+WRTkZEtpe1OaPu+3335x0EEHxbXXXlsUYj3zzDOxYcOGLdZRrVq1aNu2bTz77LOx9957R/369aNdu3axYcOGOOKII+L000+Ptm3bRpUqVeKFF16I/Pz8Mo0NtMsuu8TIkSOjf//+0aNHj+jTp0/k5+fH3XffHa1atYrLL798q9f5bYceemj8+te/joULF6aFT4cddlg8+OCD0apVq2JjVG2PMaXuu+++WL58eXz++ecREfHKK6/Ev/71r4j4Zn/ddHnYY489Fv37949HH300zj333BLX98ILL8TVV18de+21V+y7777FzlA78sgjiy4pmz9/frRu3brEM342+fZg75tsOivqwAMPjJNOOiltXk5OzhbPFlu0aFF07Ngx+vTpE23atImIiPHjx8drr70WRx11VJx44oklvvbbStuXrbEtY0p99dVX8frrr8epp5663cffAmAnke3b/wFAUl5//fXUeeedl2rTpk2qZs2aqdzc3NSee+6ZGjRoUCo/Pz9t2bVr16bOP//8VJ06dVK1atVKnX766anFixenIiI1bNiwouWGDRuWiojU+++/nzrttNNStWrVStWrVy81cODA1Ndff1203IQJE1InnnhiqlmzZqnc3NxUs2bNUn369El99NFHae+7bt261MiRI1P77bdfKi8vL1WvXr1U586dU8OHD0+tWLGiaLkPP/wwddhhh6WqVau2xduzz549O3XVVVelOnXqlKpfv36qSpUqqaZNm6Z+8pOfpGbMmFFs+d/85jep5s2bp/Ly8lKHHHJI6t1330316NEj1aNHj6JlJk6cmIqI1HPPPZf22pJuW7+pT0uWLCmxzlTqm9vR77fffhnnlaY3pe3zJ598kurVq1cqLy8v1bhx49Qvf/nL1J///OdURKQmTpxYtFy/fv1SLVu2THvtW2+9lercuXMqNze3aHtYunRp6pJLLkm1adMmVaNGjVSdOnVS3bp1S/3hD3/Y7OfdXM9SqVTq2WefTXXs2DGVl5eXql+/fuqnP/1p6l//+lfaMv369UvVqFFji+/zbStXrkxVrlw5VatWrdSGDRuKpj/55JOpiEidc845W7W+knz66aepiEg9+uijGee3bNkyFREZH59++mnRcvfee28qIlLjxo3b7Ptt2s5Kenz7//a9995LRUTqmmuu2erPVdL2v2rVqlREpM4888zNvn7ZsmWps88+O7XnnnumqlevnsrLy0vtt99+qVtuuSW1bt26jK/JtJ2Uti/f9txzzxXrRXkZM2ZMKiJSL7/8crmvG4CdU04qVYoRRwEAYCttOhvp3nvvjTPPPDNq165d7M6KpXH66afH/PnzY9q0aeVW2/333x9XX311fPLJJ+U2IPdrr70Wxx13XMyaNSv233//clnnunXrYuXKlfHMM8/EoEGD4p133ik6Y3J79AUAkrT97o0MAADxzaV4DRs2jJdffnmrX5tKpWLSpEnxq1/9qlxrmjhxYlx66aXleoe4iRMnxplnnllugVTEN0FXw4YNY9CgQWnTt1dfACBJzpQCAGC7+M9//hN/+9vfip4fcMAB0ahRoyxW9P2zZMmSmDVrVtHzbt26FRsgHQC+r4RSAAAAACTO5XsAAAAAJE4oBQAAAEDihFIAAAAAJK5KtgtIWmFhYXz++edRq1atyMnJyXY5AAAAADuVVCoVq1atimbNmkWlSiWfD1XhQqnPP/88WrRoke0yAAAAAHZqCxcujF133bXE+RUulNp0C92FCxdG7dq1s1wNAAAAwM5l5cqV0aJFi6IMpiQVLpTadMle7dq1hVIAAAAA28mWhk0y0DkAAAAAiRNKAQAAAJA4oRQAAAAAiRNKAQAAAJA4oRQAAAAAidshQqnRo0dHq1atomrVqtGtW7eYNm1aics+9thjkZOTk/aoWrVqgtUCAAAAsK2yHko9++yzMWTIkBg2bFjMmDEj2rdvH717947FixeX+JratWvHF198UfT47LPPEqwYAAAAgG2V9VBq1KhRMWDAgOjfv3+0bds2xowZE9WrV4+xY8eW+JqcnJxo0qRJ0aNx48YJVgwAAADAtspqKLVu3bqYPn169OrVq2hapUqVolevXjF16tQSX7d69epo2bJltGjRIk488cSYM2dOicsWFBTEypUr0x4AAAAAZFdWQ6mlS5fGxo0bi53p1Lhx41i0aFHG1+yzzz4xduzYeOmll+LJJ5+MwsLCOPjgg+Nf//pXxuVHjBgRderUKXq0aNGi3D8HAAAAAFsn65fvba3u3btH3759o0OHDtGjR494/vnno2HDhvHggw9mXP7aa6+NFStWFD0WLlyYcMUAAAAAfFeVbL55gwYNonLlypGfn582PT8/P5o0aVKqdeyyyy7RsWPHmDdvXsb5eXl5kZeXt821AgAAAFB+snqmVG5ubnTu3DkmTJhQNK2wsDAmTJgQ3bt3L9U6Nm7cGO+99140bdp0e5UJAAAAQDnL6plSERFDhgyJfv36RZcuXaJr165x1113xZo1a6J///4REdG3b99o3rx5jBgxIiIibrrppjjooINizz33jOXLl8ftt98en332WVxwwQXZ/BgAAAAAbIWsh1JnnHFGLFmyJIYOHRqLFi2KDh06xLhx44oGP1+wYEFUqvTfE7qWLVsWAwYMiEWLFkW9evWic+fO8dZbb0Xbtm2z9REAAAAA2Eo5qVQqle0ikrRy5cqoU6dOrFixImrXrp3tcgAAAAB2KqXNXr53d98DAAAA4PtPKAUAAABA4oRSAAAAACROKAUAAABA4rJ+9z1g+2t1zZ+yXcJ2M//WY7NdAgAAAGXgTCkAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxVbJdAEDSWl3zp2yXsN3Mv/XYbJcAAABQKs6UAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxQikAAAAAEieUAgAAACBxO0QoNXr06GjVqlVUrVo1unXrFtOmTSvV65555pnIycmJk046afsWCAAAAEC5ynoo9eyzz8aQIUNi2LBhMWPGjGjfvn307t07Fi9evNnXzZ8/P6688so49NBDE6oUAAAAgPKS9VBq1KhRMWDAgOjfv3+0bds2xowZE9WrV4+xY8eW+JqNGzfGT3/60xg+fHjsvvvuCVYLAAAAQHnIaii1bt26mD59evTq1atoWqVKlaJXr14xderUEl930003RaNGjeL888/f4nsUFBTEypUr0x4AAAAAZFdWQ6mlS5fGxo0bo3HjxmnTGzduHIsWLcr4mr/97W/xyCOPxEMPPVSq9xgxYkTUqVOn6NGiRYttrhsAAACAbZP1y/e2xqpVq+Kcc86Jhx56KBo0aFCq11x77bWxYsWKosfChQu3c5UAAAAAbEmVbL55gwYNonLlypGfn582PT8/P5o0aVJs+U8++STmz58fxx9/fNG0wsLCiIioUqVKzJ07N/bYY4+01+Tl5UVeXt52qB4AAACAssrqmVK5ubnRuXPnmDBhQtG0wsLCmDBhQnTv3r3Y8m3atIn33nsvZs6cWfQ44YQT4vDDD4+ZM2e6NA8AAADgeyKrZ0pFRAwZMiT69esXXbp0ia5du8Zdd90Va9asif79+0dERN++faN58+YxYsSIqFq1arRr1y7t9XXr1o2IKDYdAAAAgB1X1kOpM844I5YsWRJDhw6NRYsWRYcOHWLcuHFFg58vWLAgKlX6Xg19BQAAAMAWZD2UiogYOHBgDBw4MOO8SZMmbfa1jz32WPkXBAAAAMB25RQkAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABK3Q4RSo0ePjlatWkXVqlWjW7duMW3atBKXff7556NLly5Rt27dqFGjRnTo0CGeeOKJBKsFAAAAYFtlPZR69tlnY8iQITFs2LCYMWNGtG/fPnr37h2LFy/OuHz9+vXjuuuui6lTp8bs2bOjf//+0b9//xg/fnzClQMAAABQVlkPpUaNGhUDBgyI/v37R9u2bWPMmDFRvXr1GDt2bMble/bsGSeffHLsu+++sccee8Tg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IiIaNGgQn3/+eUR8Mxj63Llzy686AAAAAHZKZTpTql27djFr1qxo3bp1dOvWLW677bbIzc2N3/72t7H77ruXd40AAAAA7GTKFEpdf/31sWbNmoiIuOmmm+K4446LQw89NH7wgx/Es88+W64FAgAAALDzKVMo1bt376J/77nnnvHhhx/GV199FfXq1Su6Ax8AAAAAlKRModS3LVy4MCIiWrRosc3FAAAAAFAxlGmg8w0bNsQNN9wQderUiVatWkWrVq2iTp06cf3118f69evLu0YAAAAAdjJlOlNq0KBB8fzzz8dtt90W3bt3j4iIqVOnxo033hhffvllPPDAA+VaJAAAAAA7lzKFUk8//XQ888wzcfTRRxdNO+CAA6JFixbRp08foRQAAAAAm1Wmy/fy8vKiVatWxaa3bt06cnNzt7UmAAAAAHZyZQqlBg4cGDfffHMUFBQUTSsoKIhf//rXMXDgwHIrDgAAAICdU6kv3zvllFPSnv/lL3+JXXfdNdq3bx8REbNmzYp169bFEUccUb4VAgAAALDTKXUoVadOnbTnp556atrzFi1alE9FAAAAAOz0Sh1KPfroo9uzDgAAAAAqkDLdfW+TJUuWxNy5cyMiYp999omGDRuWS1EAAAAA7NzKNND5mjVr4rzzzoumTZvGYYcdFocddlg0a9Yszj///Fi7dm151wgAAADATqZModSQIUPir3/9a7zyyiuxfPnyWL58ebz00kvx17/+Na644oryrhEAAACAnUyZLt/7n//5n/jjH/8YPXv2LJp2zDHHRLVq1eL000+PBx54oLzqAwAAAGAnVKYzpdauXRuNGzcuNr1Ro0Yu3wMAAABgi8oUSnXv3j2GDRsW//nPf4qmff311zF8+PDo3r17uRUHAAAAwM6pTJfv3XXXXXHUUUfFrrvuGu3bt4+IiFmzZkXVqlVj/Pjx5VogAAAAADufMoVS+++/f3z88cfx1FNPxYcffhgREX369Imf/vSnUa1atXItEAAAAICdz1aHUuvXr482bdrEq6++GgMGDNgeNQEAAACwk9vqMaV22WWXtLGkAAAAAGBrlWmg80suuSRGjhwZGzZsKO96AAAAAKgAyjSm1DvvvBMTJkyIN954I/bff/+oUaNG2vznn3++XIoDAAAAYOdUplCqbt26ceqpp5Z3LQAAAABUEFsVShUWFsbtt98e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BQWxcuXKtAcAAAAA2ZW1UGrp0qWxcePGaNy4cdr0xo0bx6JFi8rtfUaMGBF16tQperRo0aLc1g0AAABA2WR9oPPt7dprr40VK1YUPRYuXJjtkgAAAAAqvCrZeuMGDRpE5cqVIz8/P216fn5+uQ5inpeXZ/wpAAAAgB1M1s6Uys3Njc6dO8eECROKphUWFsaECROie/fu2SoLAAAAgARk7UypiIghQ4ZEv379okuXLtG1a9e46667Ys2aNdG/f/+IiOjbt280b948RowYERHfDI7+/vvvF/373//+d8ycOTNq1qwZe+65Z9Y+BwAAAABbJ6uh1BlnnBFLliyJoUOHxqJFi6JDhw4xbty4osHPFyxYEJUq/fdkrs8//zw6duxY9PyOO+6IO+64I3r06BGTJk1KunwAAAAAyiiroVRExMCBA2PgwIEZ5303aGrVqlWkUqkEqgIAAABge9rp774HAAAAwI5HKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUAAABA4oRSAAAAACROKAUA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ADuuKtkuAACgLE499dRYt25dPP7447H77rtHfn5+TJgwIb788stsl1YmCxYsiFdffTXuvffeYvPmzp0btWvXjq+//jpeeeWVuPjii2OPPfaII444IiIi6tevn0iN69ati9zc3GjSpEm5rzs3NzfOOuusuOeee+LQQw8t9/UDADseZ0oBAN87y5cvjylTpsTIkSPj8MMPj5YtW0bXrl3j2muvjRNOOCEiIubPnx85OTkxc+bMtNfl5OTEpEmT0tb35ptvxgEHHBBVq1aNgw46KP75z38Wzfvss8/i+OOPj3r16kWNGjViv/32i9dee61o/j//+c84+uijo2bNmtG4ceM455xzYunSpRERce6558Zf//rXuPvuu4vOdpo/f37Gz/SHP/wh2rdvH82bNy82r1GjRtGkSZNo3bp1XHrppdG6deuYMWNG0fxvn43Vs2fP+Oyzz+Lyyy8ves/NfY758+fH4YcfHhER9erVi5ycnDj33HOL1jVw4MC47LLLokGDBtG7d++ISL98b1Ofn3/++Tj88MOjevXq0b59+5g6dWraZ3jooYeiRYsWUb169Tj55JNj1KhRUbdu3bRljj/++Hj55Zfj66+/ztgjAGDnIpQCAL53atasGTVr1owXX3wxCgoKtnl9V111VfzmN7+Jd955Jxo2bBjHH398rF+/PiIiLrnkkigoKIjJkyfHe++9FyNHjoyaNWtGxDch149+9KPo2LFjvPvuuzFu3LjIz8+P008/PSIi7r777ujevXsMGDAgvvjii/jiiy+iRYsWGWuYMmVKdOnSZbN1plKpGDduXCxYsCC6deuWcZnnn38+dt1117jpppuK3nNzn6NFixbxP//zPxHxzRlZX3zxRdx9991F63v88ccjNzc33nzzzRgzZkyJtV133XVx5ZVXxsyZM2PvvfeOPn36xIYNGyLim9DvoosuisGDB8fMmTPjyCOPjF//+tfF1tGlS5fYsGFD/P3vf99sHwCAnYPL9wCA750qVarEY489FgMGDIgxY8ZEp06dokePHnHmmWfGAQccsNXrGzZsWBx55JER8U0Is+uuu8YLL7wQp59+eixYsCBOPfXU2H///SMiYvfddy963X333RcdO3aMW265pWja2LFjo0WLFvHRRx/F3nvvHbm5uVG9evUtXvL22WeflRhK7brrrhERUVBQEIWFhXHTTTfFYYcdlnHZ+vXrR+XKlaNWrVpp77m5z7Hp8r9GjRoVO3tpr732ittuu22ztUdEXHnllXHsscdGRMTw4cNjv/32i3nz5kWbNm3i3nvvjaOPPjquvPLKiIjYe++946233opXX301bR3Vq1ePOnXqxGeffbbF9wMAvv+cKQUAfC+deuqp8fnnn8fLL78cRx11VEyaNCk6deoUjz322Favq3v37kX/rl+/fuyzzz7xwQcfRETEpZdeGr/61a/ikEMOiWHDhsXs2bOLlp01a1ZMnDix6MytmjVrRps2bSIi4pNPPtmqGr7++uuoWrVqxnlTpkyJmTNnxsyZM+Phhx+OW265JR544IGtWv/mPsfmdO7cuVTLfTsMbNq0aURELF68OCK+OQOra9euact/9/km1apVi7Vr15bqPQGA7zehFADwvVW1atU48sgj44Ybboi33norzj333Bg2bFhERFSq9M2vOalUqmj5TZfkbY0LLrgg/u///i/OOeeceO+996JLly5Fg5GvXr06jj/++KLAaNPj448/LvFMppI0aNAgli1blnFe69atY88994z99tsv+vfvH+ecc07Gy9/K+jk2p0aNGqVa/y677FL0703jWBUWFm5VjRERX331VTRs2HCrXwcAfP8IpQCAnUbbtm1jzZo1ERFFwcamMZUiIm3Q8297++23i/69bNmy+Oijj2LfffctmtaiRYu46KKL4vnnn48rrrgiHnrooYiI6NSpU8yZMydatWoVe+65Z9pjU5iTm5sbGzdu3GLtHTt2jPfff79Un7Ny5cqbHQy8pPcs6XPk5uZGRJSqzrLYZ5994p133kmb9t3nEd+cXfaf//wnOnbsuF3qAAB2LEIpAOB758svv4wf/ehH8eSTT8bs2bPj008/jeeeey5uu+22OPHEEyPim8vADjrooLj11lvjgw8+iL/+9a9x/fXXZ1zfTTfdFBMmTIh//vOfce6550aDBg3ipJNOioiIyy67LMaPHx+ffvppzJgxIyZOnFgUWF1yySXx1VdfRZ8+feKdd96JTz75JMaPHx/9+/cvCnhatWoVf//732P+/PmxdOnSEs8e6t27d0ydOjVjMLR48eJYtGhRfPbZZ/Hcc8/FE088UfQ5M2nVqlVMnjw5/v3vfxfdCXBzn6Nly5aRk5MTr776aixZsiRWr15div+F0hs0aFC89tprMWrUqPj444/jwQcfjNdff73ojKpNpkyZErvvvnvsscce5fr+AMCOSSgFAHzv1KxZM7p16xZ33nlnHHbYYdGuXbu44YYbYsCAAXHfffcVLTd27NjYsGFDdO7cOS677LL41a9+lXF9t956awwePDg6d+4cixYtildeeSXt7KFLLrkk9t133zjqqKNi7733jvvvvz8iIpo1axZvvvlmbNy4MX784x/H/vvvH5dddlnUrVu36PLBK6+8MipXrhxt27aNhg0bxoIFCzLWcPTRR0eVKlXiL3/5S7F5++yzTzRt2jT23HPP+MUvfhE/+9nPNnvp3U033RTz58+PPfbYo+iMsc19jubNm8fw4cPjmmuuicaNG8fAgQO39F+wVQ455JAYM2ZMjBo1Ktq3bx/jxo2Lyy+/vNgYWr///e9jwIAB5freAMCOKyf17YEWAADImtGjR8fLL78c48ePz3Yp292AAQPiww8/jClTpkRExJw5c+JHP/pRfPTRR1GnTp0sVwcAJKFKtgsAAOAbP/vZz2L58uWxatWqqFWrVrbLKVd33HFHHHnkkVGjRo14/fXX4/HHHy86Uyvim7G/fve73wmkAKACcaYUAADb3emnnx6TJk2KVatWxe677x6DBg2Kiy66KNtlAQBZJJQCAAAAIHEGOgcAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcUIpAAAAABInlAIAAAAgcf8PTJTBZFegC50AAAAASUVORK5CYII=\n"
          },
          "metadata": {}
        },
        {
          "output_type": "stream",
          "name": "stdout",
          "text": [
            "\n",
            "Analysis:\n",
            "The bitstrings with the highest probabilities are the solutions.\n",
            "The classical solutions were: ['1010', '0111']\n",
            "Compare these with the peaks in the plot above.\n"
          ]
        }
      ]
    }
  ],
  "metadata": {
    "colab": {
      "provenance": []
    },
    "kernelspec": {
      "display_name": "Python 3",
      "name": "python3"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 0
}
